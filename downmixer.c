/*
 * SDR-Library by DJ0ABR
 * 
 * downmixer.c
 * ===========
 * the downmixer works like a real anaog mixer, it shifts the frequency down by some amount.
 * 
 * Example:
 * The input signal is 1 MHz,
 * the LO frequency is 900 kHz
 * the output of the down mixer is the input signal shifted
 * down to 1MHz-900kHz = 100 kHz
 * 
 * this function is mainly used to shift a signal down to the baseband (0 Hz) 
 * for SSB demodulation.
 * 
 * Functional blocks:
 * 1) NCO ... digital oscillator, made with a simulated DDS Synthesizer
 *    and a sine wave lookup table.
 * 2) Multiplier ... mixing is done by multiplication of the input signal
 *    with the LO frequency (the NCO output)
 * 3) low pass filter ... pass only the wanted frequencies are passed
 * 
 * NCO ... theory of operation
 * ==========================
 * 
 * NCO's reference clock:
 * ----------------------
 * In an SDR we already have a sampling frequency generated by the receiver/soundcard.
 * We use this also as the reference clock for the NCO, which means that we increment
 * the NCO's accumulator with every sample.
 * 
 * Increment:
 * ----------
 * the increment (FSW) defines the out frequency of the NCO:
 * Fout = FSW * Fclk / 2^N
 * i.e.:
 * N = 32 bit (the accumulator has 32 bits)
 * Fclk = 2,4MHz (the SDRs sampling rate is 2.4 Msamples/s)
 * FSW = i.e. 1e9 (frequency control word to the the wanted output frequency)
 * 
 * Fout = 1e9 * 2.4e6 / (2^32) = 558 794 Hz
 * 
 * the other way round: which FSW do we need for a given output frequency ?
 * FCW = Fout * 2^N / Fclk
 * FCW = 558 794 * 2^32 / 2.4e6 = 1e9
 * (this is the formular we need to the the mixer LO frequency)
 * 
 * sine wave lookup table:
 * -----------------------
 * we do not need all 32 bits from the accumulator because the lookup table would be
 * much too long. Instead we throw away the lower 16 bits and just use the upper 16
 * bits. A 16 bit table gives a good SNR, much better than only 8 bits.
 * 
 * multiplier:
 * -----------
 * this is a simple multiplication ob the samples and the LO
 * 
 * low pass filter:
 * ----------------
 * is required to remove the mirror. The filter must be broad enough for the wanted frequencies, i.e.
 * 4 kHz for voice
 * 
 * */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include "playSDRweb.h"
#include "downmixer.h"
#include "fir_table_calc.h"

void init_downmixer_fir_filters();
int fir_filter_i_ssb(double sample);
int fir_filter_q_ssb(double sample);

#define SINETABSIZE 65536
short sinetable[SINETABSIZE];   // 16 bit sine wave lookup table, each value is a signed short, like the soundcard samples
int samplerate;
unsigned int fcw;               // frequency control word, used to set the NCOs frequency

// initialize the mixer, must be called once at program start
void downmixer_init(int sr)
{
    samplerate = sr;

    // fill the sinewave lookup table
    double v = 0;
    for(int i=0; i<SINETABSIZE; i++)
    {
        sinetable[i] = sin(v) *32768;
        v += (2*M_PI)/SINETABSIZE;
    }
    
    init_downmixer_fir_filters();
    
    // set a default frequency of 10kHz
    downmixer_setFrequency(10000);
}

// calculate the fcw from the wanted frequency
void downmixer_setFrequency(int fr)
{
    fcw = (unsigned int)((double)fr * pow(2,32) / (double)samplerate);
}

// get next NCO sine wave value
// this increments the NCO to the next step
// do this for every sample
short increment_NCO()
{
static unsigned int accu = 0;

    // advance the NCO to the next step
    // accu automatically overflows at 2^32 
    accu += fcw;
    accu &= 0xffffffff;     // if uint has > 32 bits, just to be sure
    return sinetable[accu >> 16];
}

// does the mixer job
// call it for every sample of the SDR hardware
// i and q samples are downmixed in exactly the same way
// information is not changed, just frequency shifted
// and is used for SDR hardware delivering I and Q signals
// (Remark: if this mixer should be use for a mono input channel (only real, no q)
// then we need also a cosine table to generate the q channel)
// isample, qsample ... input, original sample from SDR hardware
// *pi, *pq ... downmixed result
//int xx=0,xxo=0;
void downmixer_process(short *pisample , short *pqsample)
{
    // get the LO
    int lo = increment_NCO();
    
    // mixing
    int ix = (int)(*pisample) * lo;
    int qx = (int)(*pqsample) * lo;
    // the result is 32 bit !
    
    // low pass filtering
    // Filter for 2.4M samplerate
    // passband: 4kHz
    // for performance reasons these filters are not "universal" filters, but written for this purpose only
    // if another filter is needed, duplicate the fir filter function
    int iflt = fir_filter_i_ssb(ix);
    int qflt = fir_filter_q_ssb(qx);
    /*if(iflt > xxo) 
    {   
        xxo = iflt;
        printf("o:%d\n\r",xxo>>15);
    }*/
    
    // above multiplication expanded the sample to 32 bit, reduce it to 16 bit
    // (a level regulation could be implemented here)
    *pisample = (short)(iflt >> 15);
    *pqsample = (short)(qflt >> 15);
}

// =================================================================================
// FIR filters used by the down mixer
// =================================================================================

#define FIRSSB_LEN  191
double ssb_ceoffs[FIRSSB_LEN];

void init_downmixer_fir_filters()
{
    createLowPassFIRfilter(samplerate, ((SSB_RATE / 2) * 21)/20 /* add 5% */, ssb_ceoffs, FIRSSB_LEN);
}

int fir_filter_i_ssb(double sample)
{
static double circular_buffer[FIRSSB_LEN];
double *pcoeff = ssb_ceoffs;
static int wr_idx = 0;
double y;

    // write value to buffer
    circular_buffer[wr_idx] = sample;
    
    // increment write index
    wr_idx++;
    wr_idx %= FIRSSB_LEN;
    
    // calculate new value
    y = 0;
    int idx = wr_idx;
    for(int i = 0; i < FIRSSB_LEN; i++)
    {
        y += (*pcoeff++ * circular_buffer[idx++]);
        if(idx >= FIRSSB_LEN) idx=0;
    }

    return (int)y;
}

int fir_filter_q_ssb(double sample)
{
static double circular_buffer[FIRSSB_LEN];
double *pcoeff = ssb_ceoffs;
static int wr_idx = 0;

    // write value to buffer
    circular_buffer[wr_idx] = sample;
    
    // increment write index
    wr_idx++;
    wr_idx %= FIRSSB_LEN;
    
    // calculate new value
    double y = 0;
    int idx = wr_idx;
    for(int i = 0; i < FIRSSB_LEN; i++)
    {
        y += (*pcoeff++ * circular_buffer[idx++]);
        if(idx >= FIRSSB_LEN) idx=0;
    }

    return (int)y;
}

// =================================================================================
// enable only for testing purposes
/*void main()
{
    downmixer_init(2400000);
    
    // test sine table
    printf("test: sine table\n");
    for(int i=0; i<SINETABSIZE; i+=1024)
    {
        printf("%d:%d ",i,sinetable[i]);
    }
    printf("\n");
    
    printf("test: default frequency\n");
    // a frequency of 24kHz at a sample rate of 2.4M
    // should have 100 samples per periode (2*PI)
    // lets show 200 samples which should have 2 periodes
    downmixer_setFrequency(24000);
    for(int i=0; i<200; i++)
    {
        short v = increment_NCO();
        printf("%d:%d ",i,v);
    }
    printf("\n");
}
*/
